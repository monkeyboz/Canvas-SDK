<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Flat Shade + Palette Items (All Features)</title>
<style>
  :root{--bg:#0f1720;--panel:#0b1220;--muted:#9aa4b2;--accent:#6ee7b7;}
  body{margin:12px;font-family:Inter,system-ui,Segoe UI,Roboto,Arial; background:var(--bg); color:#e6eef6;}
  header{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  h1{font-size:18px;margin:0 8px 0 0}
  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  label{font-size:13px;color:var(--muted)}
  input[type=range]{vertical-align:middle}
  button{background:var(--panel);border:1px solid #213040;padding:8px 10px;color:#dff;cursor:pointer}
  button:disabled{opacity:.5;cursor:default}
  .wrap{display:flex;gap:12px;margin-top:12px;align-items:flex-start}
  .left{flex:1;min-width:360px}
  canvas{width:100%;background:#111;border:1px solid #223;display:block}
  .right{width:420px;max-width:42vw;background:linear-gradient(180deg,#071018, #07121e);padding:12px;border-radius:6px;border:1px solid #122;box-shadow:0 6px 20px rgba(0,0,0,.6)}
  .palette{display:flex;flex-wrap:wrap;gap:6px;margin-top:8px}
  .sw{width:34px;height:34px;border:1px solid #122;cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:11px;color:#bcd}
  .sw.sel{outline:3px solid rgba(110,231,183,.16)}
  .items{margin-top:8px;max-height:58vh;overflow:auto}
  .item{display:flex;gap:8px;align-items:center;padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,.02)}
  .thumb{width:72px;height:48px;border:1px solid #233;flex:none}
  .meta{font-size:12px;color:var(--muted)}
  .badge{background:#0b2030;padding:4px 6px;border-radius:6px;font-size:12px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center}
  .small{font-size:12px;color:var(--muted)}
  footer{margin-top:12px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<header>
  <h1>Flat Shade + Palette Items (D — Full)</h1>
  <div class="controls">
    <label><input id="file" type="file" accept="image/*"> Load image</label>
    <label class="small">Method:
      <select id="method"><option value="kmeans">K-means</option><option value="posterize">Posterize</option></select>
    </label>
    <label class="small">K: <input id="k" type="number" min="2" max="64" value="8" style="width:64px"></label>
    <label class="small">Dither <input id="dither" type="checkbox"></label>
    <label class="small">Resample(for Kmeans): <input id="resample" type="number" min="1" max="8" value="3" style="width:56px"></label>
    <label class="small">Preserve edges <input id="edges" type="checkbox" checked></label>
    <button id="apply">Apply</button>
    <button id="download" disabled>Download PNG</button>
  </div>
</header>

<div class="wrap">
  <div class="left">
    <div style="margin-bottom:8px" class="small">Original</div>
    <canvas id="src"></canvas>
    <div style="height:12px"></div>
    <div style="margin-bottom:8px" class="small">Result (click palette to isolate; click items to highlight)</div>
    <canvas id="out"></canvas>
  </div>

  <aside class="right">
    <div class="small">Palette</div>
    <div id="palette" class="palette"></div>

    <div style="margin-top:8px" class="small">Palette stats</div>
    <div id="stats" class="small" style="margin-top:6px"></div>

    <div style="margin-top:8px" class="small">Items (connected components)</div>
    <div id="items" class="items"></div>

    <div style="margin-top:10px" class="row">
      <div class="badge" id="selInfo">No selection</div>
    </div>
  </aside>
</div>

<footer>Tip: use resample 2–4 for fast K-means on large images. Posterize is instant.</footer>

<script>
/* -------------- Utilities -------------- */
const fileEl = document.getElementById('file');
const methodEl = document.getElementById('method');
const kEl = document.getElementById('k');
const ditherEl = document.getElementById('dither');
const resampleEl = document.getElementById('resample');
const edgesEl = document.getElementById('edges');
const applyBtn = document.getElementById('apply');
const downloadBtn = document.getElementById('download');

const srcCanvas = document.getElementById('src'), outCanvas = document.getElementById('out');
const sCtx = srcCanvas.getContext('2d'), oCtx = outCanvas.getContext('2d');

const paletteEl = document.getElementById('palette'), itemsEl = document.getElementById('items'), statsEl = document.getElementById('stats'), selInfo = document.getElementById('selInfo');

let loadedImg = null;
let quantizedImage = null; // ImageData of quantized result
let palette = [];
let ccData = []; // connected components info
let selectedPaletteIndex = -1;
let highlightRegion = null;

// Load image
fileEl.addEventListener('change', (e)=>{
  const f = e.target.files?.[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  const img = new Image();
  img.onload = () => {
    loadedImg = img;
    // cap width to 1400 for practical canvas size (maintain aspect)
    const maxW = 1400;
    let w = img.width, h = img.height;
    if (w > maxW) {
      const scale = maxW / w;
      w = Math.round(w * scale);
      h = Math.round(h * scale);
    }
    srcCanvas.width = outCanvas.width = w;
    srcCanvas.height = outCanvas.height = h;
    sCtx.drawImage(img, 0, 0, w, h);
    quantizedImage = null;
    palette = []; ccData = [];
    paletteEl.innerHTML = '';
    itemsEl.innerHTML = '';
    statsEl.textContent = '';
    downloadBtn.disabled = true;
    URL.revokeObjectURL(url);
  };
  img.src = url;
});

/* ---------- Image helpers ---------- */
function getImageData(ctx) {
  return ctx.getImageData(0,0,ctx.canvas.width, ctx.canvas.height);
}
function putImageData(ctx, imgData) {
  ctx.putImageData(imgData, 0, 0);
}
function copyImageData(im) {
  return new ImageData(new Uint8ClampedArray(im.data), im.width, im.height);
}
function rgbDist2(a,b){ const dx=a[0]-b[0], dy=a[1]-b[1], dz=a[2]-b[2]; return dx*dx+dy*dy+dz*dz; }

/* ---------- Edge detection (simple sobel to preserve silhouette) ---------- */
function computeEdges(gray, w, h, threshold=30) {
  // Sobel (magnitude)
  const out = new Uint8ClampedArray(w*h);
  for (let y=1;y<h-1;y++){
    for (let x=1;x<w-1;x++){
      const gx = -gray[(y-1)*w + (x-1)] -2*gray[y*w + (x-1)] - gray[(y+1)*w + (x-1)]
                 + gray[(y-1)*w + (x+1)] +2*gray[y*w + (x+1)] + gray[(y+1)*w + (x+1)];
      const gy = -gray[(y-1)*w + (x-1)] -2*gray[(y-1)*w + x] - gray[(y-1)*w + (x+1)]
                 + gray[(y+1)*w + (x-1)] +2*gray[(y+1)*w + x] + gray[(y+1)*w + (x+1)];
      const mag = Math.hypot(gx, gy);
      out[y*w+x] = mag > threshold ? 255 : 0;
    }
  }
  return out;
}

/* ---------- Posterize (fast) ---------- */
function posterize(imgData, bits, dither=false) {
  const steps = Math.pow(2, bits);
  const w = imgData.width, h = imgData.height;
  const data = imgData.data;
  if (!dither) {
    for (let i=0;i<data.length;i+=4){
      for (let c=0;c<3;c++){
        let v = data[i+c];
        let q = Math.floor(v/256*steps);
        let out = Math.round(q * (255/(steps-1)));
        data[i+c] = out;
      }
    }
    return imgData;
  }
  // simple dithering (Floyd–Steinberg)
  const arr = new Float32Array(data.length);
  for (let i=0;i<data.length;i++) arr[i]=data[i];
  for (let y=0;y<h;y++){
    for (let x=0;x<w;x++){
      const idx = (y*w + x)*4;
      for (let c=0;c<3;c++){
        const oldv = arr[idx+c];
        const q = Math.round((oldv/255)*(steps-1));
        const newv = q*(255/(steps-1));
        const err = oldv - newv;
        arr[idx+c] = newv;
        if (x+1 < w) arr[idx+4 + c] += err * 7/16;
        if (x-1 >=0 && y+1 < h) arr[idx + (w-1)*4 + 4 + c] += err * 3/16;
        if (y+1 < h) arr[idx + w*4 + c] += err * 5/16;
        if (x+1<w && y+1<h) arr[idx + (w+1)*4 + c] += err * 1/16;
      }
    }
  }
  for (let i=0;i<data.length;i++) data[i] = Math.max(0, Math.min(255, Math.round(arr[i])));
  return imgData;
}

/* ---------- K-means quantization ---------- */
function subsamplePixels(imgData, step) {
  const w=imgData.width,h=imgData.height;
  const samples = [];
  for (let y=0;y<h;y+=step){
    for (let x=0;x<w;x+=step){
      const i=(y*w+x)*4;
      samples.push([imgData.data[i], imgData.data[i+1], imgData.data[i+2]]);
    }
  }
  return samples;
}

// kmeans++ init + iterative update - returns palette (array of [r,g,b])
function kmeansPalette(samples, K, maxIter=20) {
  // choose first centroid random
  const cent = [];
  cent.push(samples[Math.floor(Math.random()*samples.length)].slice());
  while (cent.length < K) {
    const dists = samples.map(s=>{
      let best = Infinity;
      for (const c of cent){
        const dx=s[0]-c[0], dy=s[1]-c[1], dz=s[2]-c[2];
        const dist = dx*dx+dy*dy+dz*dz;
        if (dist < best) best = dist;
      }
      return best;
    });
    // pick new centroid weighted by dist
    let sum = dists.reduce((a,b)=>a+b,0);
    if (sum === 0) { cent.push(samples[Math.floor(Math.random()*samples.length)].slice()); continue; }
    let r = Math.random()*sum;
    let idx = 0;
    while (r > dists[idx]) { r -= dists[idx]; idx++; if (idx>=dists.length) break; }
    cent.push(samples[idx].slice());
  }
  // iterate
  for (let it=0; it<maxIter; it++){
    const buckets = Array.from({length:K}, ()=>({sum:[0,0,0],count:0}));
    for (const s of samples){
      let best=0,bestD=Infinity;
      for (let i=0;i<K;i++){
        const c=cent[i];
        const dx=s[0]-c[0], dy=s[1]-c[1], dz=s[2]-c[2];
        const d=dx*dx+dy*dy+dz*dz;
        if (d<bestD){bestD=d;best=i;}
      }
      buckets[best].sum[0]+=s[0]; buckets[best].sum[1]+=s[1]; buckets[best].sum[2]+=s[2]; buckets[best].count++;
    }
    let moved=0;
    for (let i=0;i<K;i++){
      if (buckets[i].count===0) {
        cent[i] = samples[Math.floor(Math.random()*samples.length)].slice();
        moved++;
        continue;
      }
      const nx=buckets[i].sum[0]/buckets[i].count;
      const ny=buckets[i].sum[1]/buckets[i].count;
      const nz=buckets[i].sum[2]/buckets[i].count;
      if (Math.abs(cent[i][0]-nx)+Math.abs(cent[i][1]-ny)+Math.abs(cent[i][2]-nz) > 0.5) moved++;
      cent[i] = [nx,ny,nz];
    }
    if (!moved) break;
  }
  return cent.map(c=>c.map(v=>Math.round(v)));
}

// Apply palette to full image (map each pixel to nearest palette color). Returns ImageData and index map
function applyPaletteToImage(imgData, palette, dither=false) {
  const w=imgData.width,h=imgData.height;
  const out = new ImageData(w,h);
  const indexMap = new Uint8Array(w*h);
  if (!dither) {
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const idx=(y*w+x)*4;
        const px=[imgData.data[idx], imgData.data[idx+1], imgData.data[idx+2]];
        let best=0,bestD=Infinity;
        for (let i=0;i<palette.length;i++){
          const d=rgbDist2(px, palette[i]);
          if (d<bestD){bestD=d;best=i;}
        }
        out.data[idx] = palette[best][0];
        out.data[idx+1] = palette[best][1];
        out.data[idx+2] = palette[best][2];
        out.data[idx+3] = 255;
        indexMap[y*w+x] = best;
      }
    }
    return {imgData: out, indexMap};
  }
  // Dithered (simple ordered noise-ish dither not full FS for performance)
  for (let y=0;y<h;y++){
    for (let x=0;x<w;x++){
      const idx=(y*w+x)*4;
      const px=[imgData.data[idx], imgData.data[idx+1], imgData.data[idx+2]];
      // jitter by small amount
      const jitter = (Math.random()-0.5)*10;
      px[0] = Math.max(0, Math.min(255, px[0] + jitter));
      px[1] = Math.max(0, Math.min(255, px[1] + jitter));
      px[2] = Math.max(0, Math.min(255, px[2] + jitter));
      let best=0,bestD=Infinity;
      for (let i=0;i<palette.length;i++){
        const d=rgbDist2(px, palette[i]);
        if (d<bestD){bestD=d;best=i;}
      }
      out.data[idx] = palette[best][0];
      out.data[idx+1] = palette[best][1];
      out.data[idx+2] = palette[best][2];
      out.data[idx+3] = 255;
      indexMap[y*w+x] = best;
    }
  }
  return {imgData: out, indexMap};
}

/* ---------- Palette harmonization / sorting ---------- */
function rgbToLuma(rgb){ return 0.299*rgb[0] + 0.587*rgb[1] + 0.114*rgb[2]; }
function rgbToSat(rgb){
  const r=rgb[0]/255, g=rgb[1]/255, b=rgb[2]/255;
  const max=Math.max(r,g,b), min=Math.min(r,g,b);
  return max-min;
}
function harmonizePalette(pal) {
  // Sort by luma ascending (dark -> light) and then by saturation descending
  return pal.slice().sort((a,b)=>{
    const la=rgbToLuma(a), lb=rgbToLuma(b);
    if (Math.abs(la-lb) > 2) return la - lb;
    return rgbToSat(b) - rgbToSat(a);
  });
}

/* ---------- Connected components per palette color ---------- */
function computeConnectedComponents(indexMap, w, h, K) {
  // For each palette index, find connected components (4-connected)
  const visited = new Uint8Array(w*h);
  const compsByColor = Array.from({length:K}, ()=>[]);
  const dx=[1,-1,0,0], dy=[0,0,1,-1];
  for (let y=0;y<h;y++){
    for (let x=0;x<w;x++){
      const pos = y*w + x;
      if (visited[pos]) continue;
      const col = indexMap[pos];
      // flood
      const stack=[pos];
      visited[pos]=1;
      const pixels=[];
      let minX=x,maxX=x,minY=y,maxY=y;
      while (stack.length){
        const p = stack.pop();
        pixels.push(p);
        const py = Math.floor(p/w), px = p % w;
        if (px < minX) minX = px;
        if (px > maxX) maxX = px;
        if (py < minY) minY = py;
        if (py > maxY) maxY = py;
        for (let k=0;k<4;k++){
          const nx = px+dx[k], ny = py+dy[k];
          if (nx<0||nx>=w||ny<0||ny>=h) continue;
          const np = ny*w+nx;
          if (visited[np]) continue;
          if (indexMap[np] !== col) continue;
          visited[np] = 1;
          stack.push(np);
        }
      }
      compsByColor[col].push({
        pixels,
        bbox: [minX,minY,maxX,minY,maxX,maxY], // we'll only use minX,minY,maxX,maxY via indices
        minX, minY, maxX, maxY,
        size: pixels.length
      });
    }
  }
  return compsByColor;
}

/* ---------- Render UI: palette and items ---------- */
function renderPalette(pal) {
  paletteEl.innerHTML = '';
  pal.forEach((c,i)=>{
    const sw = document.createElement('div');
    sw.className = 'sw';
    sw.style.background = `rgb(${c[0]},${c[1]},${c[2]})`;
    sw.title = `#${i} rgb(${c.join(',')})`;
    sw.dataset.index = i;
    if (i===selectedPaletteIndex) sw.classList.add('sel');
    sw.onclick = ()=> {
      // clicking toggles isolation
      selectedPaletteIndex = selectedPaletteIndex === i ? -1 : i;
      // Rerender outCanvas to show isolation
      drawOutput({isolateIndex:selectedPaletteIndex});
      renderPalette(palette);
    };
    paletteEl.appendChild(sw);
  });
}

function renderItems(compsByColor, pal, totalPixels) {
  itemsEl.innerHTML='';
  statsEl.textContent = '';
  const statsLines = [];
  for (let ci=0; ci<pal.length; ci++){
    const comps = compsByColor[ci];
    if (!comps || comps.length === 0) continue;
    // sort comps by size descending
    comps.sort((a,b)=>b.size - a.size);
    const sum = comps.reduce((s,c)=>s+c.size,0);
    statsLines.push(`Color ${ci}: ${comps.length} regions — ${Math.round(sum/totalPixels*10000)/100}%`);
    // show up to first 8 comps to avoid giant UI
    const showN = Math.min(12, comps.length);
    for (let j=0;j<showN;j++){
      const comp = comps[j];
      const div = document.createElement('div');
      div.className = 'item';
      const thumb = document.createElement('canvas');
      thumb.className = 'thumb';
      const tw = comp.maxX - comp.minX + 1;
      const th = comp.maxY - comp.minY + 1;
      // draw thumbnail scaled into thumb canvas
      thumb.width = tw;
      thumb.height = th;
      const tctx = thumb.getContext('2d');
      // fill with transparent then paint pixels
      const timg = tctx.createImageData(tw, th);
      // paint component pixels white on transparent
      for (const p of comp.pixels){
        const py = Math.floor(p / outCanvas.width), px = p % outCanvas.width;
        const tx = px - comp.minX, ty = py - comp.minY;
        const ii = (ty*tw + tx)*4;
        timg.data[ii] = pal[ci][0];
        timg.data[ii+1] = pal[ci][1];
        timg.data[ii+2] = pal[ci][2];
        timg.data[ii+3] = 255;
      }
      tctx.putImageData(timg, 0, 0);
      // scale thumbnail visually to fixed size while preserving aspect
      const container = document.createElement('div');
      container.style.display='flex';
      container.style.flexDirection='column';
      container.style.alignItems='flex-start';
      container.appendChild(thumb);
      const meta = document.createElement('div');
      meta.className='meta';
      meta.innerHTML = `Color ${ci} • size: ${comp.size} px • bbox: ${comp.minX},${comp.minY} → ${comp.maxX},${comp.maxY}`;
      container.appendChild(meta);
      div.appendChild(container);
      // click to highlight this region on main canvas
      div.onclick = () => {
        highlightRegion = {colorIndex:ci, comp};
        drawOutput({highlightRegion});
        selInfo.textContent = `Highlight: color ${ci}, size ${comp.size}`;
        // scroll canvas into view
        srcCanvas.scrollIntoView({behavior:'smooth', block:'center'});
      };
      itemsEl.appendChild(div);
    }
  }
  statsEl.textContent = statsLines.join(' | ');
}

/* ---------- Draw output (with options to isolate or overlay edges/highlight) ---------- */
function drawOutput(opts={isolateIndex:-1, highlightRegion:null}) {
  if (!quantizedImage) return;
  const w = outCanvas.width, h = outCanvas.height;
  const outImg = copyImageData(quantizedImage.imgData);
  // if isolate index requested, set other pixels transparent/black
  const iso = opts.isolateIndex !== undefined ? opts.isolateIndex : -1;
  if (iso >= 0) {
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const p = (y*w+x);
        const idx = p*4;
        if (quantizedImage.indexMap[p] !== iso) {
          // fade to dark transparent look
          outImg.data[idx] = 12; outImg.data[idx+1] = 12; outImg.data[idx+2] = 16;
        }
      }
    }
  }
  // overlay edges if asked
  if (edgesEl.checked && quantizedImage.edges) {
    // draw crisp black edges onto outImg
    for (let i=0;i<w*h;i++){
      if (quantizedImage.edges[i]) {
        const idx = i*4;
        outImg.data[idx] = 10; outImg.data[idx+1] = 10; outImg.data[idx+2] = 10;
      }
    }
  }
  // highlight region if present
  if (opts.highlightRegion || highlightRegion) {
    const hr = opts.highlightRegion || highlightRegion;
    // overlay semi-transparent white on region
    for (const p of hr.comp.pixels){
      const idx = p*4;
      // blend: out = mix(out, highlightColor, alpha)
      outImg.data[idx] = Math.round((outImg.data[idx]*0.2) + (255*0.8));
      outImg.data[idx+1] = Math.round((outImg.data[idx+1]*0.2) + (255*0.8));
      outImg.data[idx+2] = Math.round((outImg.data[idx+2]*0.2) + (120*0.8));
    }
  }
  oCtx.putImageData(outImg, 0, 0);
}

/* ---------- Main apply handler ---------- */
applyBtn.addEventListener('click', async ()=>{
  if (!loadedImg) { alert('Load an image first'); return; }
  applyBtn.disabled = true; applyBtn.textContent = 'Working...';
  await new Promise(r=>setTimeout(r,10)); // let UI update

  const method = methodEl.value;
  const K = Math.max(2, Math.min(64, parseInt(kEl.value)||8));
  const dither = ditherEl.checked;
  const resample = Math.max(1, parseInt(resampleEl.value)||2);
  const w = srcCanvas.width, h = srcCanvas.height;
  const srcImg = getImageData(sCtx);

  // optionally compute edges from original to preserve silhouette
  // compute grayscale first
  const gray = new Uint8ClampedArray(w*h);
  for (let y=0;y<h;y++){
    for (let x=0;x<w;x++){
      const i=(y*w+x)*4;
      gray[y*w+x] = Math.round(0.299*srcImg.data[i] + 0.587*srcImg.data[i+1] + 0.114*srcImg.data[i+2]);
    }
  }
  let edges = null;
  if (edgesEl.checked) edges = computeEdges(gray, w, h, 40);

  if (method === 'posterize') {
    // Posterize quick path
    const bits = Math.max(1, Math.min(8, parseInt(prompt('Posterize bits (1-8)', '4')) || 4));
    const copy = copyImageData(srcImg);
    const res = posterize(copy, bits, dither);
    palette = []; // derive palette from result
    // collect palette by scanning
    const map = new Map();
    for (let i=0;i<res.data.length;i+=4){
      const key = `${res.data[i]},${res.data[i+1]},${res.data[i+2]}`;
      if (!map.has(key)) map.set(key,0);
      map.set(key, map.get(key)+1);
    }
    palette = Array.from(map.keys()).map(k=>k.split(',').map(v=>parseInt(v)));
    palette = harmonizePalette(palette);
    // apply edges overlay
    if (edgesEl.checked) {
      for (let i=0;i<w*h;i++){
        if (edges[i]) {
          const idx = i*4;
          res.data[idx]=10; res.data[idx+1]=10; res.data[idx+2]=10;
        }
      }
    }
    // build indexMap mapping each pixel to nearest palette index
    const indexMap = new Uint8Array(w*h);
    for (let y=0;y<h;y++){
      for (let x=0;x<w;x++){
        const p=(y*w+x)*4;
        const px=[res.data[p], res.data[p+1], res.data[p+2]];
        let best=0,bestD=Infinity;
        for (let i=0;i<palette.length;i++){
          const d = rgbDist2(px, palette[i]);
          if (d < bestD){bestD=d;best=i;}
        }
        indexMap[y*w+x]=best;
      }
    }
    quantizedImage = {imgData: res, indexMap, edges};
    // compute components and UI
    const comps = computeConnectedComponents(indexMap, w, h, palette.length);
    const total = w*h;
    renderPalette(palette);
    renderItems(comps, palette, total);
    ccData = comps;
    drawOutput({isolateIndex:-1});
    downloadBtn.disabled = false;
    applyBtn.disabled=false; applyBtn.textContent='Apply';
    return;
  }

  // Kmeans path
  // 1) subsample for clustering
  const sampleStep = Math.max(1, Math.round(resample));
  const samples = subsamplePixels(srcImg, sampleStep);
  // If image is mostly large, reduce sample size further for speed
  const MAX_SAMPLES = 90000;
  if (samples.length > MAX_SAMPLES) {
    // uniformly downsample the samples array
    const stride = Math.ceil(samples.length / MAX_SAMPLES);
    const s2 = [];
    for (let i=0;i<samples.length;i+=stride) s2.push(samples[i]);
    samples.length = 0;
    samples.push(...s2);
  }
  // run kmeans to produce palette
  await new Promise(r=>setTimeout(r,10));
  palette = kmeansPalette(samples, K, 24);
  palette = harmonizePalette(palette);

  // 2) apply palette to full image
  const applied = applyPaletteToImage(srcImg, palette, dither);
  // if edges enabled: compute edge mask (we already computed edges)
  quantizedImage = {imgData: applied.imgData, indexMap: applied.indexMap, edges};
  // 3) compute connected components (this can be expensive)
  const comps = computeConnectedComponents(applied.indexMap, w, h, palette.length);
  ccData = comps;
  // 4) UI render
  const total = w*h;
  renderPalette(palette);
  renderItems(comps, palette, total);
  drawOutput({isolateIndex:-1});
  downloadBtn.disabled = false;
  applyBtn.disabled=false; applyBtn.textContent='Apply';
});

/* ---------- Download ---------- */
downloadBtn.addEventListener('click', ()=>{
  // merge edges if enabled already present in quantizedImage.imgData
  if (!quantizedImage) return;
  // create copy to avoid mutating cached
  const outCopy = copyImageData(quantizedImage.imgData);
  // if edges enabled and not drawn already, draw them
  if (edgesEl.checked && quantizedImage.edges) {
    for (let i=0;i<outCopy.width*outCopy.height;i++){
      if (quantizedImage.edges[i]) {
        const idx = i*4;
        outCopy.data[idx]=10; outCopy.data[idx+1]=10; outCopy.data[idx+2]=10;
      }
    }
  }
  // If a palette isolation is active, darken others
  if (selectedPaletteIndex >= 0) {
    for (let p=0;p<outCopy.width*outCopy.height;p++){
      if (quantizedImage.indexMap[p] !== selectedPaletteIndex) {
        const idx=p*4;
        outCopy.data[idx]=12; outCopy.data[idx+1]=12; outCopy.data[idx+2]=16;
      }
    }
  }
  // If highlight exists, overlay
  if (highlightRegion) {
    for (const p of highlightRegion.comp.pixels){
      const idx = p*4;
      outCopy.data[idx] = Math.round((outCopy.data[idx]*0.2) + (255*0.8));
      outCopy.data[idx+1] = Math.round((outCopy.data[idx+1]*0.2) + (255*0.8));
      outCopy.data[idx+2] = Math.round((outCopy.data[idx+2]*0.2) + (120*0.8));
    }
  }
  // Draw to out canvas and export
  oCtx.putImageData(outCopy,0,0);
  const link = document.createElement('a');
  link.href = outCanvas.toDataURL('image/png');
  link.download = 'flat_shaded_with_items.png';
  link.click();
});
  
/* ---------- Initialize small helper interactions ---------- */
// Clicking on out canvas toggles next palette color isolation for quick browsing
outCanvas.addEventListener('click', (ev)=>{
  if (!palette || palette.length===0) return;
  // cycle selection
  selectedPaletteIndex = (selectedPaletteIndex + 1) % palette.length;
  drawOutput({isolateIndex:selectedPaletteIndex});
  renderPalette(palette);
});
</script>
</body>
</html>

